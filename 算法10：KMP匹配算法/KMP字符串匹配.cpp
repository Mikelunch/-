#include<iostream>
using namespace std;

const int N = 1e7;
int ne[N];// 用于存储下次跳转的位置
char S[N], p[N]; //输入字符串 模板字符串

int main() {
    int n, m;
    cin >> n >> p + 1 >> m >> S + 1; //注意 这里默认从数组下标1开始

    //计算ne数组 得到对应长度下的最大匹配字符串 其思想是模板串自己和自己进行子字符串匹配
    //实现的具体内容：对每个i长度的字符串 找到最长的前缀和后缀字符串匹配 并记录下后缀的起始下标到ne[i]数据中
    for (int i = 2, j = 0; i <= n; i++) {//注意 这里默认从i = 2开始 因为长度为0 和1的字符串没有前缀和后缀子串
        //如果j ！= 0 且者p[i] != p[j + 1] 则跳转到匹配到的子字符串的下一个起点
        //反过来说就是 j =0即还没有找到起始点的情况 或者说p[i] == p[j + 1] 即当前前缀和后缀子字符串仍可以匹配 不是最长的匹配情况下，则不是跳转点
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j++; //寻找到了终点 因为从上一行while()退出的条件之一
        ne[i] = j; //记录当前长度下的子字符串跳转起点或者 j = 0,也记录下来
    }

    //进行字符匹配
    for (int i = 1, j = 0; i <= m; i++) { //匹配模式默认从下标1开始进行
        //同ne实现一样 在j = 0即已经到了匹配长度的最短极限或者说 字符串的匹配仍可以进行 则不用跳转
        while (j && S[i] != p[j + 1]) j = ne[j];//部分匹配 则我们跳转到以部分匹配的长度为界的最长匹配子字符串位置
        if (S[i] == p[j + 1]) j++;//匹配的长度仍可以继续加长直到 j == n为止
        if (j == n) { //和模板字符串p匹配成功
            cout << i - n << ' '; //第一次是输出起点 第二次是输出终点
            j = ne[j];
        }
    }


    return 0;
}

作者：ConstantZ
链接：https ://www.acwing.com/activity/content/code/content/7506705/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。