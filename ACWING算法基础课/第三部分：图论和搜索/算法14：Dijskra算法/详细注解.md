## 朴素Dijkstra算法

### 薇妹镇楼

![维尔利特.jpg](https://cdn.acwing.com/media/article/image/2024/03/11/352015_180154c0df-维尔利特.jpg) 

## 算法核心思路
d[]:每个点到起点的距离 s[]:已经确定了最短路径的点 
(1) **初始化**： d[起点] = 1 , d[其余点] = 超过边权的数
(2) **查找**: 遍历所有节点 ，将**不在s[]但距离起点路径最短的点找到** 该点为 **t**
(3) **更新**: 
1.遍历所有节点 用找到的t去更新其余点的最短距离d[]
2.将t插入s[] 已表示该点距离起点的最短里找到
朴素Dijkstra算法的**核心思想**便是：**不积跬步无以至千里**。每次只更新附近一点到起点的最短距离，一步一步走到最后，则终点到起点的最短路径一定是由中间节点的最短路径组成。学习算法也是这样

## 三点疑问
### 图中出现重边和自环怎么办？
1.对于重边，**只记录其最小的权重值即可**
2.对于自环，在更新距离时会被判断掉不是最短路径，所以本题不用判断
### 如何找到**不在s[]但距离起点路径最短的点**？
只要满足 两点需求：(1)该点不是s[]中的点 (2)该点是整个图中除s[]外距离起点最近的点
算法的具体实现如下
```
for(int i = 1; i <=n ; i++){//第二步：遍历节点
    int t = -1;//当前节点还在待定
    for(int j = 1; j <= n; j++){//寻找不在st[]中的距离最近的点
        if(!st[j] && (t == -1 || d[t] > d[j]))  //未在s[]中且 t目前仍然待定或者时目前找到的t距离遍历到的新节点更大
            t = j;//则更新t
    }
```
### 怎样用找到的t去更新其余点的最短距离d[]
代码如下:
```
for(int j = 1 ; j <= n ; j++){
        if(d[j] > d[t] + g[t][j])
            d[j] = d[t] + g[t][j];
    }
}
```
**为什么上诉代码不考虑两点是否连接？**
因为在邻接矩阵的初始化时 所有权值按比输入的最大权值还要大的值处理。所以在面对
```
if(d[j] > d[t] + g[t][j])
    d[j] = d[t] + g[t][j];
```
这个比较时 两个未连接的点的权值一定是不更新的

## 全部代码如下：
```
#include<iostream>
#include<cstring>
using namespace std;
const int N = 502;
int n , m;
int g[N][N];//邻接矩阵 存储的是权重值
int d[N];//每个点到起点的最短距离
bool st[N];//每个点的最短路是否已经确定

int dijkstra(void){
    memset(d , 0x3f3f3f3f , sizeof d);
    d[1] = 0; //第一步 初始化各点的距离 除起点外均为最大值
    for(int i = 1; i <=n ; i++){//第二步：遍历节点
        int t = -1;//当前节点还在待定
        for(int j = 1; j <= n; j++){//寻找不在st[]中的距离最近的点
            if(!st[j] && (t == -1 || d[t] > d[j])) 
                t = j;
        }
        st[t] = true;//加入到已发现的最短路节点中去
        for(int j = 1 ; j <= n ; j++){//第三步：用t去更新其他点 为什么不用管这两点时候连接？ 因为初始化距离是是按最大值初始化的
            if(d[j] > d[t] + g[t][j])
                d[j] = d[t] + g[t][j];
        }
    }
    if(d[n] == 0x3f3f3f3f) return -1;//说明起点到n点不互通
    return d[n];
}

int main(){
    scanf("%d %d" , &n  , &m);
    memset(g , 0x3f3f , sizeof g);
    while(m--){
        int a , b , x;
        scanf("%d %d %d" , &a , &b , &x);
        g[a][b] = g[a][b] > x ? x : g[a][b]; //重边情况下进保留距离最短的一条边 自环亦然
    }
    cout << dijkstra()  << endl;
    return 0;
}
```
